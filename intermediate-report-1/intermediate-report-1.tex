\documentclass{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage[a4paper]{geometry}
\begin{document}

\title{中間レポート1}
\author{学籍番号 1029-25-7819　　名前 五十嵐　雄}
\date{}
\maketitle

\section{はじめに}
本実験の実装はHaskellで行っている。不明な点があれば以下に挙げる資料を中心に参照せよ。
\begin{itemize}
\item https://www.haskell.org/documentation (リファレンス集)
\item https://www.haskell.org/hoogle/ (Haskell用の検索エンジン)
\end{itemize}

\section{課題1}
\subsection{回答コード}
\begin{verbatim}
int array[8];

void initialize(int *array);
void sort(int *array);

int main(){
  int i;
  initialize(array);
  sort(array);
  for(i = 0; i < 8; i = i + 1) print(array[i]);
}

void initialize(int *array){
  int i;
  for(i = 0; i < 8; i = i + 1){
    array[i] = 8 - i;
  }
}

void sort(int *array){
  int i, j, tmp;
  for(i = 0; i < 7; i = i + 1){
    for(j = i+1; j < 8; j = j + 1){
      if(array[i] > array[j]){
        tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
      }
    }
  }
}
\end{verbatim}
\subsection{プログラムの説明}
\begin{description}
\item[initialize] \mbox{} \\
配列の先頭のポインタを受け取って、配列の先頭から降順の数値で埋める。
\item[sort] \mbox{} \\
 配列の先頭のポインタを受け取って、バブルソートを行う。
\end{description}

\section{課題5}
\subsection{課題の回答}
抽象構文木のデータ構造は src/AST.hs 構文解析器は src/Parser.hs をそれぞれ参照せよ。

\subsection{ASTの設計方針}
以下にデータ構造を列挙して説明していく。説明の過程で実験資料のBNFで使われている用語が登場するので適宜参照せよ。またSourcePosはソース名と位置情報を持った組み込みのデータ型であり、全てのノードが持っている。詳細は Text.Parsec.Pos.hs (公式ライブラリ)を参照せよ。

\subsubsection{型シノニム}
よく現れる型に対してエイリアスを張っている。このような型シノニムを適切に定義することで型注釈がより実際の動作を反映したものとなりプログラムが読みやすくなっていく。未知の型も登場するがこのあと説明するのでまずは先へ進むこと。
\begin{verbatim}
type Program    = [EDecl]
type Identifier = String
type DeclList   = [(Type, DirectDecl)] -
\end{verbatim}
\begin{itemize}
\item Program プログラム全体はEDecl(external-declaration)のリストで表現される。
\item Identifier 識別子は文字列で表現される。
\item DeclList 変数宣言は型とdirect-declarationの組によって表現される。
\end{itemize}

\subsubsection{EDecl}
external-declarationに対応するデータ構造である。グローバル変数宣言(declaration)、プロトタイプ宣言(function-prototype)、関数定義(function-definition)の3つの役割を果たす。以下にそれぞれのノードについて解説する。
\begin{verbatim}
data EDecl = Decl          SourcePos DeclList
           | FuncPrototype SourcePos Type Identifier [(Type, Identifier)]
           | FuncDef       SourcePos Type Identifier [(Type, Identifier)] Stmt
\end{verbatim}
\begin{itemize}
\item Decl SourcePos DeclList \mbox{} \\
グローバルな変数宣言についてのノードであり具体的な内容はDeclListによって表現される。型宣言は先頭の一つだけだが、そのあとに続く変数は整数とポインタで別々の型を取りうるので、各変数と型はこの時点で一対一に対応させている。\\
\item FuncPrototype SourcePos Type Identifier [(Type, Identifier)] \mbox{} \\
プロトタイプ宣言についてのノードである。左から返り値の型、関数名、引数リストである。引数リストは型と識別名だけ分かれば良いためそれらを組にしたリストとしている。\\
\item FuncDef SourcePos Type Identifier [(Type, Identifier)] Stmt\mbox{} \\
関数定義についてのノードである。プロトタイプ宣言と同様のデータ構造に加えて関数本体をStmtとして持っている。実際はBNFの定義によりcompound-stmtだけが来るようになっている。\\
\end{itemize}

\subsubsection{Type}
SmallCの型に対応するデータ型。定義は以下のようである。
\begin{verbatim}
data Type = CPointer Type
          | CInt
          | CVoid
\end{verbatim}
現状の文法ではCPointer CInt, CInt, CVoidしか現れないことになっているが、CPointerの引数を自分自身とすることで、char型やポインタのポインタといった拡張にも自然に対応することができる。

\subsubsection{DirectDecl}
direct-declarationに対応するノードである。型情報はさらに上のレベルで付加されるのでこのノードには必要ない。コードは以下である。
\begin{verbatim}
data DirectDecl = Variable SourcePos Identifier
                | Sequence SourcePos Identifier Integer
\end{verbatim}
Variableは変数で識別名だけを持っている。Sequenceは配列で識別名と配列サイズを持っている。

\subsubsection{Stmt}
statementに対応するノードである。定義は以下のようになる。
\begin{verbatim}
data Stmt = EmptyStmt    SourcePos
          | ExprStmt     SourcePos Expr
          | DeclStmt     SourcePos DeclList
          | CompoundStmt SourcePos [Stmt]
          | IfStmt       SourcePos Expr Stmt Stmt
          | WhileStmt    SourcePos Expr Stmt
          | ReturnStmt   SourcePos Expr
\end{verbatim}
以下に各コンストラクタを説明していく。
\begin{itemize}
\item EmptyStmt SourcePos \mbox{} \\
空の文(;)に対応する。
\item ExprStmt SourcePos Expr \mbox{} \\
expressionの文に対応する。
\item DeclStmt SourcePos DeclList \mbox{} \\
compound-statementの中に登場する変数宣言文を表現するノード。compound-statement以外には現れない。
\item CompoundStmt SourcePos [Stmt] \mbox{} \\
compound-statementに対応するノード。中カッコで囲まれた部分に現れる複数のstatementをリスト形式で保持している。
\item IfStmt SourcePos Expr Stmt Stmt \mbox{} \\
if文に対応するノード。左から条件節、True節、False節を保持している。elseのないif文はFalse節をEmptyStmtにすることで実現している。
\item WhileStmt SourcePos Expr Stmt \mbox{} \\
while文対応するノード。左から条件節と本体である。
\item returnStmt SourcePos Expr \mbox{} \\
return文に対応するノード。与えられたExprを保持する
\end{itemize}

\subsubsection{Expr}
expressionに対応するノードである。BNF上では結合の強さによって文法要素が入れ子状に表現されているが、データ構造では同じレベルに置いて実装している。正しい構文要素が現れていることは構文解析の実装や意味解析によって担保していくためこの段階では大雑把な定義になっている。実際の定義は以下のようになる。
\begin{verbatim}
data Expr = AssignExpr   SourcePos Expr Expr
          | UnaryPrim    SourcePos String Expr
          | BinaryPrim   SourcePos String Expr Expr
          | ArrayAccess  SourcePos Expr Expr
          | ApplyFunc    SourcePos String [Expr]
          | MultiExpr    SourcePos [Expr]
          | Constant     SourcePos Integer
          | IdentExpr    SourcePos Identifier
\end{verbatim}
以下に各コンストラクタを説明していく。

\begin{itemize}
\item AssignExpr SourcePos Expr Expr \mbox{} \\
代入文(assign-expr)に対応するノードである。左のExprがディスティネーションで右のExprがソースである。
\item UnaryPrim SourcePos String Expr \mbox{} \\
単項演算子の適用に対応するノードである。Stringに演算子、Exprに適用する項を保持している。
\item BinaryPrim SourcePos String Expr Expr \mbox{} \\
二項演算子の適用に対応するノードである。Stringに演算子、残りはそれぞれ左オペランドと右オペランドに対応している。
\item ArrayAccess SourcePos Expr Expr \mbox{} \\
配列アクセスに対応したノードである。左のExprがソースに対応し、右のExprが添字に対応する。ソース部分にArrayAccessが現れても良いので文法上は多重配列アクセスも可能になっている。
\item ApplyFunc SourcePos String [Expr] \mbox{} \\
関数適用に対応したノードである。Stringは適用先の関数名で[Expr]が引数リストになっている。
\item Constant SourcePos Integer \mbox{} \\
定数に対応したノード。単純に符号付き数を保持している。
\item IdentExpr SourcePos Identifier \mbox{} \\
変数に対応したノード。識別子を文字列で保持している。
\end{itemize}
\subsection{Parserの設計方針}
標準ライブラリのText.Parsecの力によりBNFをそのまま書き写すだけでほぼ実装が完了するため、関数を逐一説明するようなことはしない。全体の大まかな流れと工夫が必要であった部分についてParser.hsを参照しながら説明していく。
\subsubsection{全体の流れ}
\begin{itemize}
\item 25行目　文法の定義 \mbox{} \\
ライブラリが提供するデータ構造に沿って、予約語と演算子を定義する。
\item 31 - 64行目　lexer \mbox{} \\
上で定義したデータ型からlexerセットを生成して、必要になるlexerを取り出す。
\item 73 - 140行目　external-declaration のパーサー \mbox{} \\
external-declarationの構文をパースする部分。externalDeclで変数宣言、プロトタイプ宣言、関数宣言の3つに分岐して各部分をパースする。DeclListを生成する部分で少し工夫があるので後述する。
\item 142 - 196行目　statement のパーサー \mbox{} \\
statementの構文をパースする部分。for文をwhile文に変換している以外は特に特別なことはしていない。
\item 198 - 234行目　expression のパーサー \mbox{} \\
expressionの構文をパースする部分。logical-OR-exorからunary-exprまでの優先度付き演算子で表現されている部分は buildExpressionParser を利用して簡潔に書いている。演算子テーブルは248行目から定義されているリストである。
\end{itemize}
\subsubsection{工夫した部分}
\begin{itemize}
\item 宣言におけるポインタの処理 \mbox{} \\
例えば $int a, *b$ というような宣言を考える。BNF上ではまず $int$ と $a, *b$に分解されてしまうのだが、意味の上では $int$ はそれぞれの変数にかからなければいけない。そこで各変数がポインタであるか否かの情報を回収し、genDecl(88行目)によって変数ごとに型を生成してDeclListとしている。pointerOp(245行目)によってポインタ演算子をパースし、checkPointer(242行目)でそれを受け取って型の変換を行っている。\\
\item 演算子の処理 \mbox{} \\
logical-OR-exprからunary-exprまでの構文木は項と演算子で構成されており、構造が非常に似ている。そこで構文木のデータ型を抽象化し演算子と項を受け取る形式にした。Haskellでは文字列レベルでのパターンマッチも可能なので後半のコード量は変わらず、かつParserのコード量を大きく削減できる。
\end{itemize}

\section{課題6}
パーサーに対するテストが test/ParserSpec.hs にいくらか定義されており、パース元のプログラムとパース結果の抽象構文木の対応を見ることができるのでそれを回答とする。\\
また文法的に正しくないプログラムを入力した場合はパース結果が $Left  ParseError$ となり位置や正しい文法要素が報告されるようになっている。これはParsecライブラリの仕様である。

\section{課題7}
回答コードは src/ProgramGenerator.hs である。実装については木を素直に辿りながら適切な文字列を生成すればよいだけなので特筆すべき点はない。プログラムの再生成自体を各データ型の Show インスタンスとしてしまうことも考えたが、結果は構文木のままで表示されたほうがデバッグしやすいため採用しなかった。

\section{感想}
HaskellでParserは書き慣れていたのでやるだけ感が強かったが、コンビネータなども調べながら楽しくコーディングできた。進捗に余裕が出てきているので最適化を頑張りたい。
\end{document}
